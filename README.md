# mysql
极客时间
# 01 基础架构:一条SQL查询语句是如何执行的？
为该讲总结了几个问题, 大家复习的时候可以先尝试回答这些问题检查自己的掌握程度:  
1. MySQL的框架有几个组件, 各是什么作用?   
2. Server层和存储引擎层各是什么作用?  
3. you have an error in your SQL syntax 这个保存是在词法分析里还是在语法分析里报错?  
4. 对于表的操作权限验证在哪里进行  
5. 执行器的执行查询语句的流程是什么样的?  

# 02 日志系统： 一条SQL更新语句是如何执行的？  
首先谈一下，学习后的收获  
redo是物理的，binlog是逻辑的；现在由于redo是属于InnoDB引擎，所以必须要有binlog，因为你可以使用别的引擎  
保证数据库的一致性，必须要保证2份日志一致，使用的2阶段式提交；其实感觉像事务，不是成功就是失败，不能让中间环节出现，也就是一个成功，一个失败  
如果有一天mysql只有InnoDB引擎了，有redo来实现复制，那么感觉oracle的DG就诞生了，物理的速度也将远超逻辑的，毕竟只记录了改动向量  
binlog几大模式，一般采用row，因为遇到时间，从库可能会出现不一致的情况，但是row更新前后都有，会导致日志变大  
最后2个参数，保证事务成功，日志必须落盘，这样，数据库crash后，就不会丢失某个事务的数据了  
其次说一下，对问题的理解  
备份时间周期的长短，感觉有2个方便  
首先，是恢复数据丢失的时间，既然需要恢复，肯定是数据丢失了。如果一天一备份的话，只要找到这天的全备，加入这天某段时间的binlog来恢复，如果一周一备份，假设是周一，而你要恢复的数据是周日某个时间点，那就，需要全备+周一到周日某个时间点的全部binlog用来恢复，时间相比前者需要增加很多；看业务能忍受的程度  
其次，是数据库丢失，如果一周一备份的话，需要确保整个一周的binlog都完好无损，否则将无法恢复；而一天一备，只要保证这天的binlog都完好无损；当然这个可以通过校验，或者冗余等技术来实现，相比之下，上面那点更重要  
# 03 事务隔离
1、务的特性：原子性、一致性、隔离性、持久性  
2、多事务同时执行的时候，可能会出现的问题：脏读、不可重复读、幻读  
3、事务隔离级别：读未提交、读提交、可重复读、串行化  
4、不同事务隔离级别的区别：  
	读未提交：一个事务还未提交，它所做的变更就可以被别的事务看到  
	读提交：一个事务提交之后，它所做的变更才可以被别的事务看到  
	可重复读：一个事务执行过程中看到的数据是一致的。未提交的更改对其他事务是不可见的  
	串行化：对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行  
5、配置方法：启动参数transaction-isolation  
6、事务隔离的实现：每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。  
7、回滚日志什么时候删除？系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。  
8、什么时候不需要了？当系统里么有比这个回滚日志更早的read-view的时候。  
9、为什么尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。  
10、事务启动方式：一、显式启动事务语句，begin或者start transaction,提交commit，回滚rollback；二、set autocommit=0，该命令会把这个线程的自动提交关掉。这样只要执行一个select语句，事务就启动，并不会自动提交，直到主动执行commit或rollback或断开连接。  
11、建议使用方法一，如果考虑多一次交互问题，可以使用commit work and chain语法。在autocommit=1的情况下用begin显式启动事务，如果执行commit则提交事务。如果执行commit work and chain则提交事务并自动启动下一个事务。  

思考题：  
在开发过程中，尽可能的减小事务范围，少用长事务，如果无法避免，保证逻辑日志空间足够用，并且支持动态日志空间增长。监控Innodb_trx表，发现长事务报警。  

疑问:  
关于第二节的思考题，读题干的意思，是在什么场景下，一天一备比一周一备更有优势。老师的答案只是给出了一天一备的优势，那么适用场景怎么理解呢？  

# 04. 深入浅出索引  
总结：
1.索引的作用：提高数据查询效率  
2.常见索引模型：哈希表、有序数组、搜索树  
3.哈希表：键 - 值(key - value)。  
4.哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置  
5.哈希冲突的处理办法：链表  
6.哈希表适用场景：只有等值查询的场景  
7.有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))  
8.有序数组查询效率高，更新效率低  
9.有序数组的适用场景：静态存储引擎。  
10.二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子  
11.二叉搜索树：查询时间复杂度O(log(N))，更新时间复杂度O(log(N))  
12.数据库存储大多不适用二叉树，因为树高过高，会适用N叉树  
13.InnoDB中的索引模型：B+Tree  
14.索引类型：主键索引、非主键索引  
	主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)  
15.主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)  
16.一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。  
17.从性能和存储空间方面考量，自增主键往往是更合理的选择。  

思考题：  
如果删除，新建主键索引，会同时去修改普通索引对应的主键索引，性能消耗比较大。  
删除重建普通索引貌似影响不大，不过要注意在业务低谷期操作，避免影响业务。  

# 05 深入浅出索引
踩过坑：有人问我联合索引的技巧，回答的不是很好
总结：
1、覆盖索引：如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据  
2、最左前缀：联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符  
3、联合索引：根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。  
4、索引下推：like 'hello%’and age >10 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age<10的数据，再进行回表查询，减少回表率，提升检索速度  

总结：  
回表：回到主键索引树搜索的过程，称为回表  
覆盖索引：某索引已经覆盖了查询需求，称为覆盖索引，例如：select ID from T where k between 3 and 5  
在引擎内部使用覆盖索引在索引K上其实读了三个记录，R3~R5(对应的索引k上的记录项)，但对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2  
最左前缀原则：B+Tree这种索引结构，可以利用索引的"最左前缀"来定位记录  
只要满足最左前缀，就可以利用索引来加速检索。  
最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符  
第一原则是：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。  
索引下推：在MySQL5.6之前，只能从根据最左前缀查询到ID开始一个个回表。到主键索引上找出数据行，再对比字段值。  
MySQL5.6引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。  

课后题：  
ca没有必要，cb有必要。因为a、b联合索引，直接查询b不会使用主键联合索引。  

疑问：  
以前看过某些文章上面写：如果查询顺序和联合索引的顺序不一致，优化器会自动做优化，是这样的吗老师  

# 06 全局锁和表锁


# 07 行锁功过

# 08 事务到底是隔离还是不隔离

